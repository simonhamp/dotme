---
id: c22879d0-9e96-4ccd-bd27-b04419dcc424
title: 'Laravel: Hacking Eloquent Relationships'
subtitle: 'I recently had the need to create a complex relationship system.'
published: false
original: medium
---



### Laravel: Hacking Eloquent Relationships

I recently had the need to create a complex relationship system.

It went like this: a *product* has *features*, some of which are exposed by adding *accessories*.

The key aspect for the function of the system is the *feature* of a *product*, as this is what users will search for. Users will need to see the total price for their chosen *product* and *features*.

The final price depends on the *features* required, as some *features* only become available by means of *accessories*. To complicate this further, some features require 2 or more *accessories*.

> So to get the final price, we have to determine all of the *accessories* that are required to fulfil the *features* that are requested for each *product* that the user has selected.

This may sound simple enough — *products* **haveMany** *features*; *features* **haveMany** *accessories*. However, to complicate matters further still, for there to be comparable and searchable *features* across the entire range of *products*, *product features* are a many-to-many relationship, with a definitive master list of *features* being matched to *products* via a pivot table, *feature\_product*.

This is fine for one level of relationships and is fully supported natively in Laravel by means of [dynamic pivot models](http://laravel.com/docs/5.0/eloquent#working-with-pivot-tables) — pivot models are dynamically generated by Laravel’s built-in *Model* base class.

However, with 3 many-to-many related objects (besides the need for more), it’s clear that the standard pivot model isn’t going to cut it.

Also, the model for accessing *product features* (and their associated accessories) isn’t under my control. In fact, there is no hard-coded model!

Because the dynamic pivot model is generated in Laravel’s core, I won’t be able to tell it how to conceive the relationship between *product features* and the *accessories* that enable each *feature.*

There is an [interesting 3-way pivot package](https://github.com/jarektkaczyk/Eloquent-triple-pivot) by [jarektkaczyk](https://github.com/jarektkaczyk/) on GitHub. However this goes a little too far in extending the pivot for my requirements and isn’t functionally on-par with the native 2-way pivot.

Requiring a 3-way pivot table actually creates a lot more rows to manage and my implementation differs significantly from the approach that this package requires.

(Is there a way to do this with the **hasManyThrough** relationship? I haven’t explored that option as yet.)

Instead I opted to ‘hack’ Laravel to override the standard Eloquent behaviour with some of my own.

> Of course when I say *‘hack’*, what follows is a completely legitimate way of overriding the functionality, and is fully supported by the framework… so don’t worry, we’re not heading down a path we shouldn’t be going.





---



First, we create a new base Model class that extends the default Eloquent Model: I’ll call mine *BaseModel*.

Next we create our own version of the built-in *newPivot()* method to override Eloquent’s own functionality.

Here we can determine which class should be instantiated to handle our pivot table.

Rather than providing a generic pivot model of my own, I wanted explicit control over every detail of each relationship, so I look for the model that matches the naming convention of my pivot table: *FeatureProduct*.

And then obviously created that model. But instead of extending Eloquent’s base Model class or even my own new base model, extending *Illuminate\\Eloquent\\Pivot*.

Thankfully, pivot table models are an extension to Eloquent Models that add no special requirements, so my model is just an Eloquent Model with all the usual stuff in it, but now it ‘just works’ when the parent models call the pivot.

The bonus of this is that now I have a model which can interact directly with my pivot table as well, meaning I can perform ‘normal’ operations on it directly.

The final step is to make sure all of my other models extend my new base model so that they use the correct version of the *newPivot()* method.





---



Although my *accessories* could also be considered many-to-many with *product features* (*feature\_product*), I decided to keep things ‘simple’ by storing a serialized array of *accessory* IDs in a column in the *feature\_product* pivot table.

This has some advantages: it keeps table reads and writes down and even negates the possibility of a join happening.

But there are drawbacks too. Obviously one of the biggest drawbacks with this implementation is that there’s no quick way to determine which products are associated with a given *accessory*.

This is actually ok for the use-case and there’s no foreseeable requirement to find *products* matched to a specific accessory. But this did present other challenges.

We also lose the ability to natively eager-load *accessories*.

I’d be interested to read your thoughts on this approach, so feel free to comment.

Some other problems arose since I implemented this too, specifically related to how [attribute casting](http://laravel.com/docs/5.0/eloquent#attribute-casting) works with *array/json* casts through a pivot.

But the most obvious drawback comes when trying to retrieve a collection of unique *accessories* for a particular *product*, which is one of the things I needed to do and why this whole process began.

For a given *product*, an available *accessory* may enable (or be required for) more than one *feature*. So the *accessories* column for a given row in my pivot table could conceivably contain a serialized array containing the same *accessory* ID as another row for the same *product* but a different *feature*.

(give a solid example)

Eloquent natively treats groups of instances of Pivot models as Collections (like it does with any Model), but in my implementation, I won’t get that automatic behaviour.

But I wanted to mimic this behaviour so that I could work with my array of IDs in the same way that I would if it were a more complex setup.

Thankfully Laravel exposes some awesome functionality to make this easy:

- The Collection class
- The ability to create scopes
- The *whereIn()* QueryBuilder method
