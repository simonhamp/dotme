---
id: 883e2941-58c9-43b1-bf77-21297280451f
title: 'Why and how you should use Tailwind to build your next Statamic theme'
subtitle: 'I have been building out a custom eCommerce solution in a Statamic (‚Äústat-a-mic‚Äù or ‚Äústa-tamic‚Äù? Dunno) website for the past few months and‚Ä¶'
published: true
---



### Why and how you should use Tailwind to build your next Statamic theme

I have been building out a custom eCommerce solution in a [Statamic](https://statamic.com/) (‚Äústat-a-mic‚Äù or ‚Äústa-tamic‚Äù? Dunno) website for the past few months and recently started on the build of the front-end part of the site.

It‚Äôs been a tough project because of time constraints with a hard deadline to tie in with some exciting company news. So a rapid build was crucial.

I‚Äôd also dipped my toes into the [Tailwind CSS framework](https://tailwindcss.com/) and was so excited by it that, even though it‚Äôs still in a pre-release stage, I wanted to use it for the theme of the site.

The good news is that with all of these tools, we managed to build something I‚Äôm truly proud of and can‚Äôt wait to show everyone.

However, in my hunt to make a quick start, I couldn‚Äôt find much help out here for integrating Statamic and Tailwind, so now that I have some time I wanted to write up some of my notes in the hopes that it helps others.





---



I also can‚Äôt stress enough that **you should try Statamic ‚ù§Ô∏è**. It‚Äôs a brilliant CMS, it has a very supportive community and v3, which is just around the corner, looks set to be one of the most flexible and powerful tools I will have ever had the pleasure of using.

Ok, gushing over.





---



Now, Tailwind is no stranger to Statamic; it‚Äôs already heavily used in the Control Panel and it‚Äôs been ‚Äòbundled‚Äô in [some of the themes](https://statamic.com/marketplace/themes).

I say *‚Äòbundled‚Äô* because if truth be told, it‚Äôs not really put to any great effect in those themes. I mean, it‚Äôs there sure, but a lot of the really cool stuff you can do with Tailwind has been left to the developer.

**And that‚Äôs absolutely fine.** These are *free* themes and they‚Äôre all pretty well advertised as ‚Äústarter‚Äù themes, so this is understandable.

Pick one of these or start from scratch. But however you get started with your next theme, I‚Äôd like to offer you some extra steps that may help save you some fuss.

That‚Äôs why in this post, I want to cover how to set up your Statamic theme to use Tailwind and **start writing the best darn CSS you‚Äôve ever written**. Spoiler alert: that might be less than you think!





---



One of the first things I thought when I saw Tailwind utility classes in HTML was‚Ä¶

> ‚ÄúYuck! Look at all those class names.‚Äù

This was almost the same problem I‚Äôd had with BEM and why I never went beyond only reading about it. (That and all of the dashes and underscores)

With Tailwind, I was really keen to get past that initial disgust and use it in earnest for a few reasons.

Sure, it was being built and used by some developers I follow who are pragmatic, make smart choices and whose opinions I respect (so was BEM).

But primarily it was for the end result: building web designs (HTML &amp; CSS) that offered developer flexibility, simplicity of expression and ease of maintenance, modification, and reuse.

Priority number 1 though has to be **providing a better experience for users**. This translates to:

- Ease of building a custom design without falling back on a specific framework‚Äôs default styles or having to override it loads.
- The ability to reduce the final CSS to the absolute minimum required to produce the same result.

Of course, I‚Äôd come from the ‚Äúbest practice‚Äù world of ‚Äúseparating my concerns‚Äù, modified slightly by the period of CSS pre-processor enlightenment, [much like Adam Wathan](https://adamwathan.me/css-utility-classes-and-separation-of-concerns/). Terse, reusable class names balanced against ‚Äòclean-looking‚Äô HTML was a worthy goal to strive for, and I would agonise over making the HTML as minimal as possible.

Then I moved onto Bootstrap in a big way. This was great for a while, but I became very conscious that there was a lot of stuff I wasn‚Äôt using and what I was using I was heavily overriding. Plus my markup was bloating to fit the rules of the framework rather than my markup taking the lead and styles adding the visual icing. This doesn‚Äôt feel like the right way to frontend anymore.

Tailwind appeared to offer something I‚Äôd not seen anywhere else. With some extra tricks, I believed that I could get to my near-ideal front-end development environment.

Let‚Äôs go.





---



Fair warning: I‚Äôve only been able to achieve all of this by using some other tools which you may or may not be familiar with: [Sass](https://sass-lang.com/), [PostCSS](https://github.com/postcss/postcss), [Webpack](https://webpack.js.org/) and [Laravel Mix](https://laravel-mix.com/). You won‚Äôt need to be overly familiar all of these tools (I‚Äôm certainly not!), but you will need a working setup of Node and NPM to get building.

> I feel I should apologise at this point, because NPM is a beast and suddenly introducing thousands of packages into your project is not ideal. But trust me when I say that the power that comes with all of those hundreds of MBs is absolutely worth it ‚Äî despite the headaches.

I‚Äôm a Laravel developer and I wanted to keep a similar workflow to my Laravel projects with this, so thats a big driver behind my implementation and tech choices.

If that makes sense to you, then hopefully this article will be really easy to follow. Even so, **none of this should be too strenuous if you‚Äôve done any front-end development in 2018**.

Finally, if you‚Äôve got time, I‚Äôve got a little bonus at the very end to help you bring your final CSS file size down massively, taking into account all of your Statamic content.

### Open your sails

This isn‚Äôt going to cover how to get started with Tailwind. The Tailwind crew have already done [a much better job](https://tailwindcss.com/docs/what-is-tailwind/) of that than I could.

So ideally you already know a bit about Tailwind. If you do, I‚Äôve got a lot less convincing to do.

If you don‚Äôt, stay here for now and I‚Äôll get you started, then when you‚Äôre ready‚Ä¶ go have a play. Once you get used to Tailwind, **you‚Äôll wish you had this to build every website you‚Äôve ever built**. So long to the ‚Äòold‚Äô way.

#### Blow me to Bermuda!

**The Right Way‚Ñ¢ to use Tailwind within Statamic is as part of your theme.**

We‚Äôre going to start with the [Storyteller Statamic theme](https://statamic.com/marketplace/themes/storyteller), which is a free starter theme from the Statamic Marketplace. I‚Äôm starting here because it gives you something nice to look at, but you‚Äôll probably want to start from scratch if your site is a completely custom design. Up to you.

Typically, once you‚Äôve downloaded the theme and installed it in your Statamic site, the next step is to initialise NPM. But let‚Äôs hold off from downloading the theme for a few minutes and do some exploration‚Ä¶

What‚Äôs going to be installed? Let‚Äôs have a look at the theme‚Äôs `package.json`:

```
<pre class="graf graf--pre graf-after--p" id="4639" name="4639">{<br></br>    "private": true,<br></br>    "scripts": { ... },<br></br>    "devDependencies": {<br></br>        "cross-env": "^5.1",<br></br>        "laravel-mix": "^1.0",<br></br>        "less": "^2.7.3",<br></br>        "less-loader": "^4.0.5"<br></br>    },<br></br>    "dependencies": {<br></br>        "tailwindcss": "^0.4.0"<br></br>    }<br></br>}
```

Right, so (as of September 2018) this theme is fetching a few outdated resources. So let‚Äôs update some bits.

Perhaps we should get the latest versions of some of those. Also, it‚Äôs using Less for CSS pre-processing, but I prefer Sass ‚Äî so I‚Äôd like to swap that out (of course, you can keep Less if you prefer or drop preprocessors altogether). So here‚Äôs an updated `package.json` we could use.

I‚Äôve added a couple of tools we‚Äôll be using later and updated the `scripts` array to those recommended by Laravel Mix.

```
<pre class="graf graf--pre graf-after--p" id="fc2e" name="fc2e">{<br></br>    "private": true,<br></br>    "scripts": {<br></br>        "dev": "npm run development",<br></br>        "development": "cross-env NODE_ENV=development node_modules/webpack/bin/webpack.js --progress --hide-modules --config=node_modules/laravel-mix/setup/webpack.config.js",<br></br>        "watch": "npm run development -- --watch",<br></br>        "watch-poll": "npm run watch -- --watch-poll",<br></br>        "hot": "cross-env NODE_ENV=development node_modules/webpack-dev-server/bin/webpack-dev-server.js --inline --hot --config=node_modules/laravel-mix/setup/webpack.config.js",<br></br>        "prod": "npm run production",<br></br>        "production": "cross-env NODE_ENV=production node_modules/webpack/bin/webpack.js --no-progress --hide-modules --config=node_modules/laravel-mix/setup/webpack.config.js"<br></br>    },<br></br>    "devDependencies": {<br></br>        "cross-env": "^5.2.0",<br></br>        "glob-all": "^3.1.0",<br></br>        "purgecss-webpack-plugin": "^1.2.1",<br></br>        "laravel-mix": "^2.1.14",<br></br>        "node-sass": "^4.9.3",<br></br>        "tailwindcss": "^0.6.5"<br></br>    }<br></br>}
```

Some other things you might then want to update include:

- the `tailwind.js` file to the latest version, merging in some config from the original theme;
- if like me you‚Äôve opted to use Sass, you‚Äôll need to change the preprocessor files a little (`.less =>¬†.scss`);
- I personally prefer front-end assets to live in `/public` and remove any magical way for the site to access stuff in `/site`‚Ä¶ just in case. To make all of this work, we‚Äôll need to modify `webpack.mix.js` and some Statamic config;
- I also prefer to follow some of the recommendations from the Statamic docs around file names.

The simplest way to do all of this is to download [this pack](https://github.com/simonhamp/theme-storyteller) that I made earlier: Storyteller 2.0, if you will.

Once you‚Äôve copied the theme files into place, you can run the build:

```
<pre class="graf graf--pre graf-after--p" id="d7b5" name="d7b5">cd /path/to/site/themes/storyteller/
```

```
<pre class="graf graf--pre graf-after--pre" id="5a82" name="5a82">npm install && npm run dev
```

When NPM finally finishes downloading everything, the build should run and the CSS will be placed in `/public/themes/storyteller/css/storyteller.css`

At this point, you should be able to load the site and everything should look the same as the original Storyteller theme.

### Alakazam!

That‚Äôs actually all there is to it! You can now go and build a beautiful theme using Tailwind.

What I have for you at this point are some tips for how to structure your theme and minimise your CSS as much as possible; lessons learned from weeks of building a Statamic theme from scratch.

#### Keep all of your theme assets together

This is probably super obvious, but it‚Äôs really useful to keep all of your theme-specific assets together in the theme folder. You don‚Äôt want half of your images in `/assets` and half in `/site/themes/storyteller/images` ‚Äî anything that needs to be variable and based on CMS content should be a field in a fieldset somewhere, pulled in by your theme.

One of the conveniences that Statamic has is to route requests to `yourdomain.com/site/themes` through to the `site` folder, even though it‚Äôs above the `public` root. I‚Äôm not a big fan of this for a couple of reasons:

1. It creates a dependency on a specific web server configuration ‚Äî I know that‚Äôs not that bad, it‚Äôs just another thing to remember in case you can‚Äôt use .htaccess or some other configuration convenience.
2. We might inadvertently make some source files available publicly that we hadn‚Äôt intended for public consumption.

For these reasons, I prefer the compiled CSS (and JS) to be placed in `/public`. So in Storyteller 2.0, [I‚Äôve bundled a ](https://github.com/simonhamp/theme-storyteller/blob/master/site/themes/storyteller/webpack.mix.js)`<a class="markup--anchor markup--p-anchor" data-href="https://github.com/simonhamp/theme-storyteller/blob/master/site/themes/storyteller/webpack.mix.js" href="https://github.com/simonhamp/theme-storyteller/blob/master/site/themes/storyteller/webpack.mix.js" rel="noopener" target="_blank">webpack.mix.js</a>`[ that does this](https://github.com/simonhamp/theme-storyteller/blob/master/site/themes/storyteller/webpack.mix.js) in a way that will work with multiple themes.

Thanks to the magic of Statamic filesystems, all you then need to do is make sure your [Themes Filesystem URL points to ](https://github.com/simonhamp/theme-storyteller/blob/master/site/settings/system.yaml#L7-L11)`<a class="markup--anchor markup--p-anchor" data-href="https://github.com/simonhamp/theme-storyteller/blob/master/site/settings/system.yaml#L7-L11" href="https://github.com/simonhamp/theme-storyteller/blob/master/site/settings/system.yaml#L7-L11" rel="noopener" target="_blank">/themes</a>` instead of `/site/themes` and then you can continue to use the `{{ theme:[css|js|asset|output] }}` tags in your templates.

#### Use Tailwind‚Äôs utilities properly

My initial approach with Tailwind was to [extract as many components](https://tailwindcss.com/docs/extracting-components) out from its base styles as possible. I‚Äôd kind of viewed Tailwind as a tool to create my own completely custom version of Bootstrap.

This helps when your goal is to go from class-stuffing:

```
<pre class="graf graf--pre graf-after--p" id="008c" name="008c"><button class="bg-blue hover:bg-blue-dark text-white font-bold py-2 px-4 rounded">Click me!</button>
```

to component classes:

```
<pre class="graf graf--pre graf-after--p" id="a895" name="a895"><button class="btn">Click me!</button>
```

But it doesn‚Äôt really help if your goal is to reduce your CSS. Why? Because browser CSS interpreters can‚Äôt reference class rules (yet): `btn` can‚Äôt simply point to all of those other class names and *inherit* their styles. So Tailwind has to actually *copy* all of the styles from those other classes into a new class rule.

That means that the more component classes you create, the more actual code is generated.

So my recommendation here is to **prefer using the utility classes in your HTML where possible *over* creating component classes**. Your final combined page size will be much smaller if you do.

Of course, that makes the most sense for one-off elements that aren‚Äôt yet being re-used. As soon as you have complex, multi-layered components that have the same styles being used in multiple places, not only does it become brittle to apply the same styles in multiple places, it shifts the weight problem to the other side of the see-saw: now your class names in HTML attributes might be adding more bytes to your page size than the CSS rules they would otherwise rely on.

*When that happens*, extract the relevant styles to a component. Unfortunately there‚Äôs no silver bullet here and this is down to you knowing your design and your project‚Äôs goals.

#### Don‚Äôt forget your pre-processor!

I‚Äôm so used to Sass that moving wholly over to another tool was going to be too many changes in one go for me. The good news is that [Tailwind uses PostCSS in Laravel Mix](https://tailwindcss.com/docs/installation#laravel-mix), so it can be wired up to run your CSS through Sass first, then PostCSS after.

Ultimately I think I will shift from Sass to PostCSS, but for now this meant I could move a bit quicker by falling back on some of my trusty SCSS tricks to make [organising and compiling](https://tailwindcss.com/docs/extracting-components#css-structure) my styles a little easier.

There are some gotchas though. One in particular is `!important`. You can use this with Tailwind rules to break the cascade where necessary, but Sass likes to pick up `!important` too and this can cause some conflicts.

So if you want to use `!important` with your Tailwind rules, you need to slap Sass on the wrists:

```
<pre class="graf graf--pre graf-after--figure" id="776a" name="776a">.btn {<br></br>  @apply bg-blue #{"!important"};<br></br>}
```

This (`#{"!important"}`) is [Sass string interpolation](http://sass-lang.com/documentation/file.SASS_REFERENCE.html#interpolation_), making the Sass interpreter just output `!important` so that it doesn‚Äôt try to do something that it can‚Äôt and allowing Tailwind to pick it up in a second or two.

I haven‚Äôt come across any other instances of this sort of conflict yet, so your mileage may vary depending on your tooling.

Basically, wherever there‚Äôs something in your stylesheet that might get picked up by both tools, **you need to think a bit about the order in which it will get processed** and you may need to apply some adjustments accordingly.

Alternatively, just forget about the preprocessor and embrace PostCSS.

#### Deployment strategies

When compiling assets from one place into another, (in this case from `/site` to `/public`), you do end up with two copies of some things ‚Äî in some cases identical copies.

If you‚Äôve not experienced this before, there are a couple of ways to deal with it for deployment:

1. **Commit the compiled files to your version control repository** So you end up with some redundant files in your repository‚Ä¶ at least you have the assurance of knowing that what‚Äôs in your repo is what will be deployed.  
    This is a totally acceptable strategy in my opinion, but it does have some drawbacks: If you‚Äôre working on a larger team, it can create some friction and confusion by creating potentially more merge issues than you want to deal with. There is also a risk that someone overwrites a production-ready compiled file with a development version.
2. Or; **Compile the assets at deployment time** This is by far my preferred approach. For sure, it takes a little more setting up ‚Äî you‚Äôll need Node &amp; NPM on your servers ‚Äî and it‚Äôs slightly riskier (Failed builds. Compiled versions in production don‚Äôt match development. This stuff happens.) but you have a cleaner repo, fewer merge issues with co-workers, and less chance of a development version making it‚Äôs way into production.  
    Still one key drawback to be aware of: sometimes NPM goes down and suddenly your production server can‚Äôt install/update a package it needs to compile the latest assets. There are ways to mitigate this, but it‚Äôs just a bit more complicated than sticking everything in the repo.

If you can, go with option 2. I especially recommend it if you‚Äôre not flying solo on a project as you‚Äôll benefit a little more from something I‚Äôll call **automatic contextual compilation**: when you‚Äôre working locally, you compile development assets, which can make debugging easier; when you deploy to production, the production compilation steps run giving you leaner compiled assets. More automation = less thinking, which is generally good when it comes to well-trodden, repetitive tasks.

Plus, the less friction you have during code push and pull, the better it will be for everyone.

**TIP:** I like to have `npm run watch` running locally pretty much all of the time when I‚Äôm working on a theme. That way I don‚Äôt need to even think about running the build step most of the time.

### Bonus round!

In case you‚Äôve *only* been reading this post and haven‚Äôt skipped ahead to the code already, I‚Äôve got a little treat for you.

[It‚Äôs no secret](https://tailwindcss.com/docs/controlling-file-size) that your final CSS when using Tailwind might be a little bigger than if you‚Äôd used other CSS frameworks. There are a number of ways to reduce the footprint of your stylesheet, but I wanted to skip straight to the best one and a great way of doing that in Statamic.

#### PurgeCSS + Tailwind + Statamic = üòç

If you choose to use Tailwind in your Statamic theme, **you‚Äôve made one of the best decisions you can this year**. This combination makes it ***extremely*** easy to [**reduce your CSS footprint down to a mere fraction of its original size**](https://tailwindcss.com/docs/controlling-file-size#removing-unused-css-with-purgecss).

For example, the project I‚Äôve been working on has a final (un-minified) CSS of over 400kb. That‚Äôs some heft. We could never go to production with that.

After employing the tricks I‚Äôm going to show you now, we brought that down to **under 50kb! üôÄ**

It‚Äôs so small that we can keep our entire site‚Äôs CSS in just one file ‚Äî just 1 HTTP request. And, thanks to browser caching, we don‚Äôt need to worry about code splitting or any other strategies just yet.

Here‚Äôs how we did it, showing the relevant parts from our `<a class="markup--anchor markup--p-anchor" data-href="https://github.com/simonhamp/theme-storyteller/blob/master/site/themes/storyteller/webpack.mix.js" href="https://github.com/simonhamp/theme-storyteller/blob/master/site/themes/storyteller/webpack.mix.js" rel="noopener" target="_blank">webpack.mix.js</a>`:

```
<pre class="graf graf--pre graf-after--p" id="dd35" name="dd35">let glob = require("glob-all");<br></br>let PurgecssPlugin = require("purgecss-webpack-plugin");
```

```
<pre class="graf graf--pre graf-after--pre" id="d370" name="d370">class TailwindExtractor {<br></br>    static extract(content) {<br></br>        return content.match(/[A-z0-9_\-\:\/\\]+/g) || [];<br></br>    }<br></br>}
```

```
<pre class="graf graf--pre graf-after--pre" id="f9d0" name="f9d0">if (process.env.NODE_ENV == 'production') {<br></br>  mix.webpackConfig({<br></br>    plugins: [<br></br>      new PurgecssPlugin({<br></br>        paths: glob.sync([<br></br>          path.join(__dirname, "js/**/*.js"),<br></br>          path.join(__dirname, "layouts/**/*.html"),<br></br>          path.join(__dirname, "templates/**/*.html"),<br></br>          path.join(__dirname, "partials/**/*.html"),<br></br>          path.join(__dirname, path_to_root, "site/content/pages/**/*.md"),<br></br>          path.join(__dirname, path_to_root, "site/addons/*/resources/views/**/*.blade.php"),<br></br>        ]),<br></br>        extractors: [<br></br>          {<br></br>            extractor: TailwindExtractor,<br></br>            extensions: [ "html", "js", "php", "vue", "md" ]<br></br>          }<br></br>        ]<br></br>      })<br></br>    ]<br></br>  });<br></br>}
```

As you can see, this is a bit of a twist on the PurgeCSS config that Tailwind recommends. We‚Äôve explicitly added a bunch of Statamic paths into the mix to make sure that all of the places that might reference class names in our CSS are inspected.

One of the great benefits from doing this (as you can see, only when `NODE_ENV=production`) is that during development you get the complete CSS, which gives you complete flexibility when coding up templates ‚Äî create a style, use it in a template, compile the CSS, refresh the page.

Then in production, PurgeCSS will run and pull out all of the CSS that we‚Äôre not using.

Add a minification step and you could end up with a *super tiny* style sheet!

#### ‚ö†Ô∏è Heads up ‚ö†Ô∏è

This isn‚Äôt perfect! It will occasionally suffer from false-positives, resulting in some rules remaining in the compiled stylesheet that you‚Äôre not actually using anywhere. That‚Äôs an unavoidable side-effect of the way the rule-matching process works. Mostly the impact of this will be minimal, so it‚Äôs fine, but worth knowing about.

More importantly, **if you reference class names dynamically** in your Statamic content (i.e. you have a field for ‚ÄúCustom CSS classes‚Äù or similar), you may need a way to run your CSS compilation on a regular schedule or on-demand from the Statamic CP to make sure those new classes that are referenced have been included. How you tackle this will depend on your specific requirements and deployment procedures.

### In conclusion

For me, Tailwind has been revolutionary. It‚Äôs completely changed the way I think about CSS. In fact, on this project, I hardly wrote any real style rules of my own! Amazing.

Statamic too has changed my mind about CMSs. Coming from the likes of WordPress, ExpressionEngine and other similar solutions, having a flat-file CMS is a dream. Everything‚Äôs in Git, everything‚Äôs super quick. But to top all of that, the actual management side, the Control Panel, is a pleasure to use and craft into a genuinely great experience for site admins and content editors.

With this flat file approach, Tailwind‚Äôs flexibility, Laravel under the hood, and the Laravel community and ecosystem building on top of the best tools available to web developers, we now have a perfect storm for building incredible web experiences backed by a client-ready CMS and to do that rapidly without cutting corners or wrestling against systems built with total backwards-compatibility in mind (I‚Äôm looking at you, WordPress!)

Without all of these, I don‚Äôt think we would have been able to get the smallest CSS I‚Äôve ever built for a whole website with just 2 developers against the clock.

I really hope that I‚Äôve convinced you to try these brilliant tools. At the very least that I‚Äôve given you a few ideas to apply to your own projects in the future. Thanks for reading!

> ‚ÄúIt was worth it if you learned something from it‚Äù  
>  ‚Äî Merlin

