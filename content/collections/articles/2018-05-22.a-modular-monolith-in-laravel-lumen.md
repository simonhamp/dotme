---
id: 8474a007-1ae5-4edb-840b-7bbb8f818353
title: 'A Modular Monolith in Laravel Lumen'
subtitle: 'If you use Laravel, youâ€™ve probably heard of Lumen. In case you havenâ€™t: Lumen is the micro-framework to Laravelâ€™s full-stack.'
published: true
---



### A Modular Monolith in Laravel Lumen

If you use Laravel, youâ€™ve probably heard of Lumen. In case you havenâ€™t: [Lumen](http://lumen.laravel.com) is the micro-framework to Laravelâ€™s [full-stack](http://laravel.com).

Lumen is meant to be fast. As far as PHP micro-frameworks go itâ€™s probably not far off being the fastest. Compared to other micro-frameworks, it probably fares pretty well.

This is made possible thanks to its default prerequisites being **a lot** slimmer than Laravelâ€™s and it differs under the hood in some fundamental ways. But developer experience still feels very much like Laravel, which is an important trick to pull off given the main frameworkâ€™s popularity and ease of use.

Basically, if youâ€™re familiar with Laravel, you *should* â€˜getâ€™ Lumen. Having said that, there does seem to be quite a few in the community who try Lumen and seem to really miss certain Laravel features, but I think theyâ€™ve maybe missed the point.

At [Elvie](http://elvie.com), we decided last year to build the next version of our API in Lumen. As a trimmed version of the framework that weâ€™ll be using for most of our web tools, itâ€™s a good fit as it keeps much of our stack familiar.

Personally, I think Lumen really shines ðŸ˜‰ in its opinionated decisions in the context of building a stateless, viewless HTTP API.

Over the course of possibly a few articles, I want to share our approach and some of the key things weâ€™ve learned about building this new API.

I should underscore all of this with a few details first though:

- Weâ€™re a small team, Iâ€™ve basically coded the main part of the API myself â€“ **some of this may not be suitable for larger teams**, but Iâ€™d be interested to get some input from those of you on larger teams: do you foresee any challenges that may arise due to our implementation?
- Before me, our CTO coded the previous version of our API basically from scratch in his own framework. That framework doesnâ€™t have *quite* the same popularity, documentation or accessibility as Laravel. It also lacks some of the things that make writing modern PHP applications enjoyable. So **thereâ€™s some legacy in this move that has shaped our decision-making but that may not be applicable to yours.**
- We have a fairly common (RESTful JSON API), but specific use-case (our workload isnâ€™t super high). I hope you love our concept and I wish it would work for everyone, but please consider this when reactingâ€¦ **Iâ€™m not recommending everyone change everything just because it works for us/they like the concept**. *Caveat emptor*
- Iâ€™m incredibly thankful for the immense prior work put in by others far smarter than me who have made this possible. Without their effort, guidance and example, this would have been much harder to pull off!
- If there are any parts youâ€™d like me to explore in more detail, please let me know and Iâ€™ll prioritise writing them up separately when I have time.





---



#### Whatâ€™s not in Lumen

Letâ€™s get this out of the way first because these are some of the typical things folks want to do when they start building an API.

The first and most important part of our API thatâ€™s not actually built *into/on* it directly is the authentication.

We spent quite a bit of time thinking about this and decided to go whole hog and set up a completely separate OAuth server to be our master authentication service. This is built on top of Laravel Passport and it is a completely separate Laravel (yes, *not Lumen* ðŸ˜±) application.

There are some key reasons for this, but the most important is that **Lumen isnâ€™t really intended to be used to run an OAuth server**, so donâ€™t try to do that. I mean, [you can](https://packagist.org/packages/dusterio/lumen-passport)â€¦ but I donâ€™t really know why anyone would. Lumen lacks too much to make a *complete* OAuth server without adding a bunch of stuff that it intentionally lacksâ€¦ and that Laravel comes with out of the box.

This is because, by default, Lumen lacks Views and other goodies. But if youâ€™re building a stateless, JSON API, views are not for you. If you need to output some HTML, you still can, but if you want Blade, for the love of all that is pure and sacred, use Laravel.

**Edit 5th September 2018**: Just this week we came across the need for Mailables and I have to admit I was surprised to find this missing from Lumen. But when I think about it, it does make a certain amount of sense. And actually it wasnâ€™t too painful to get Mailables up and running in Lumen.

Thereâ€™s probably a huge list of other gripes that people have with stuff that Lumen lacks. I actually donâ€™t want to go into those because as it turns out, we havenâ€™t hit any of them. I can only assume that this is because weâ€™re using Lumen in the way it was intended.

> If you need Laravel, use Laravel.

If youâ€™re tempted to think that youâ€™re on some sort of â€œI need more than Lumen but less than Laravelâ€ middle ground, **I strongly urge you to reexamine your life choices**.





---



Aside of what a typical Lumen install doesnâ€™t have by default, there are some other things that *our* Lumen instance intentionally lacks:

- routes
- models
- controllers
- migrations
- config
- interfaces
- traits
- basically any real business logic at all.

Waitâ€¦ what!? How exactly are we using Lumen then?

Well, I like to think of Lumen as the **shell**.

![](https://cdn-images-1.medium.com/max/800/1*Pik9aa7VMse23wALmqI_Ug.jpeg)
Turtle power

#### A Ghost in the Shell

*After we started building, Dan Manges wrote an interesting article on an approach he termed* [*The Modular Monolith*](https://medium.com/@dan_manges/the-modular-monolith-rails-architecture-fb1023826fc4)*. I think weâ€™re on the same path here, spiritually. I would really recommend you having a read of his article at some point if you havenâ€™t already.*

Ok so youâ€™re probably wondering where our API is and if I can really justify writing about Lumen at all if this supposed Lumen app is basically empty?

Well of course *all* of our API *is* in Lumen, Iâ€™m not lying. But strictly speaking almost none of it physically exists as part of a single, concise Lumen installation â€“ **it exists as packages**.

This was probably the most exciting idea in this whole project for me because I believe this particular design choice is incredibly powerful.

Why build things this way? And how can we do so with Lumen?

The â€˜whyâ€™ comes down to how our old API was structured and how our new one will be developed and consumed. We had a few issues.

Our old API has this concept of **modules** that are grouped units of functionality centred around areas of concern and/or specific client applications.

Each module contains its own functionality but shares common parts of the outer API with other modules, such as authentication, validation, DAL, request/response handling and serialization.

Our first-party clients typically only access one of these at a time. So in a way it would be easier to think of them as separate applications.

The thing is, theyâ€™re **not;** theyâ€™re all part of a single application and, significantly, the same git repo â€” itâ€™s a monolith! And perhaps worse: it doesnâ€™t use Composer ðŸ˜±

This presents some challenges when building on the API. Even as a team of just two devs, tagging and deploying can get kinda hairy. Any change to a single module is seen as a version bump **for the entire application**.

It also creates annoying brain work around deciding/debating whether a breaking change in one module should be reflected in a major version number bump across the entire platform.

Itâ€™s then impossible to use semantic versioning as an external indicator of the APIâ€™s version. So we basically have to have two versioning methods and thereâ€™s absolutely no parity between them.

This is quite jarring and a bit tricky to get your head around when client applications are looking at a version number that rarely changes while your internal version numbers are changing wildly. Thereâ€™s just a lot of potential for weirdness there that I really donâ€™t like.

**Wouldnâ€™t it be nicer if we could work on each module as a separate project?**

â€œYeh, definitely!â€

Hereâ€™s how we settled on packages.

#### MaaM: Module as a microservice

This is possibly the go-to solution. And itâ€™s obvious why â€” it fits so nicely with the idea of separate projects for each module, it ticks the popular opinion box, it feels like any new team members would just â€˜get itâ€™ and it would be super easy to extract our existing code out into discrete applications.

This is a common approach and verrrrry flexible. It kind of feels right, but at the same time also sort of wrong. It may solve some problems, but it brings us different ones.

For example, any change we want to make to the common features of our â€˜APIâ€™ (here representing the whole collection of microservices) requires each service to be updated individually, basically repeating a bunch of changes in each one. So long, D.R.Y.

And you know for us it just seemed to add a whole bunch of cognitive load. Weâ€™re a small team. Our ideal right now is a single application. One deployment (or as close to one as we can get for as long as we can). One thing to update. Less room for error. Simpler development and testing.

- We donâ€™t *need* separate services for all of these parts right now, at least not for the scale.
- Multiple services means a lot of extra copies of dependencies and opportunity for stuff to get into inconsistent states and possibly cause unexpected side-effects.
- It would add a lot of extra work at different stages of development and deployment which we donâ€™t have time/resources for yet.

![](https://cdn-images-1.medium.com/max/800/1*BCFs7ladjSlX4LELCHur-Q.jpeg)
Source unknown

Riffing on that a bit, we figured we could make a package that represents the common parts and have each microservice import that package.

Thatâ€™s not bad. It means any change to shared functionality only needs to be made once.

But even then, when we have multiple microservices out there, weâ€™ve got to make sure they all use the same/compatible versions of the common package otherwise we might end up in a pickle.

The next logical step seemed even better: instead of full-blown micro-services, why not set up **each module as a package**?

This is a really simple concept thatâ€™s super powerful and flexible. But itâ€™s by no means a new oneâ€¦





---



Letâ€™s have a quick diversion for a bit on how this is possible.

Laravel (and by extension Lumen) and many other frameworks include a concept for allowing external code (typically from third-parties) to hook into the framework and extend it.

In Laravel, these are **Packages**. For Symfony, itâ€™s **Bundles**. Most others use the word **Plugin**. And Iâ€™m sure still others have come up with even more creative/obscure alternative names.

They all boil down to basically the same thing: a way for developers to build reusable libraries of code that other developers can (hopefully, â€˜easilyâ€™) drop in to their applications to quickly add new functionality.

Usually thereâ€™s nothing stopping you from building your apps without any. But the complete opposite is also true too: some developers like to build their *entire* applications out of packages/bundles/plugins.

In the Symfony ecosystem, thereâ€™s been some change of heart on this: it used to be **recommended** to build your app this way, even if none of your Bundles were being reused. Now [theyâ€™ve stopped making that recommendation](https://symfony.com/doc/current/bundles.html) and suggest that only your **reusable** code need be rolled up into Bundles.





---



You need to decide whatâ€™s right for your application, but in this case it felt like the right fit for us. So we decided to go all the way with this and build each module out as its own package. That way each package can:

- be its own repo, versioned and tagged separately;
- can be worked on, tested and deployed in isolation or in combination by multiple people in multiple ways more easily with less chance of breaking and ruining someoneâ€™s dinner;
- contain ONLY the code that relates to their specific areas of concern and nothing that isnâ€™t relevant to them.

Laravel has really [great support for packages](https://laravel.com/docs/5.5/packages). Lumen inherits a lot of this for free too. Using Composer, we can easily `require` our own packages, which in turn can have their own dependencies.

In production thereâ€™s less duplication and more consistency, but we still have a lot of flexibility.

Package-specific config, migrations, routes and more are all contained in the package and loaded dynamically using a Service Provider and the dependency injection container!

Itâ€™s super slick and it works really well. Plus it covers all our acronym bases: DRY, KISS, and yes even CRUD!

And the actual API application:

- can stay as one application â€” new developer onboarding is super easy;
- is the one true place to update all the things (we just do one `composer update` to update everything);
- still has the flexibility to become individual microservices super easily if we ever need to break off one or more modules and are ready to take on that challenge!





---



Ok, so weâ€™re going to build out a package for each module. Decision made! w00t!

Taking a step back though, it was clear that most of our modules â€” now called Suites â€” would still share some common code. And if we were going to have really lightweight projects for development, weâ€™d need a way to boot up some parts of our full Lumen application for testing and such.

#### Packages all the way down

It feels kind of natural at that point to jump back to the main Lumen app and start adding a bunch of base classes there and be done. But that poses a big problem: if all of your hooks between packages and the application exist in the application codebase, weâ€™re really tightly coupling all the pieces making up this monolith-esque thing again, making all the effort of breaking our modules out a bit redundant.

This is when it became clear that we actually needed **another package**. This one would be shared by our Lumen shell *and* each Suite: **our Support package**.

Very much like Laravelâ€™s own Illuminate packages, our Support package contains a bunch of base and abstract classes, interfaces, traits, events etc etc.

By making it a Composer requirement of each Suite and the API shell, we can make use of Composerâ€™s built-in version management to work out safe deployment paths for production and identify issues with incompatible versions early on in development.

This allows us to keep our Composer dependencies for each package down to the absolute minimum required.

It also encourages us to version our packages properly and use appropriate version constraints in our `composer.json` files.

The Support package includes everything needed for testing against the Lumen stack so itâ€™s insanely easy to get going on some meaningful work. Thereâ€™s no arduous set up of a massive monolithic repo with multiple databases and too much config.

If youâ€™ve got nothing on your machine but a basic dev environment (Git, Sublime, PHP, Composer) you can pull down a single Suite and get going â€” you probably donâ€™t even need a database!

Having a Support package also has some other nice side-effects. It gives us a good place to store a bunch of other one-off and superfluous items that would otherwise sit in the Lumen app. This is a good way of looking out for â€˜future youâ€™ in case we find a way to reuse them or they come in handy for testing.

> Thinking about and organising your packages carefully goes a long way to building and managing multiple, linked projects that much easier.

It also allows us to type-hint against our base classes and such from within Lumen and our Suites to give us greater guarantees around consistency and expected functionality. Thatâ€™s pretty sexy.

Iâ€™ve got to be honest, I learned a lot from the Laravel codebase in this regard. Itâ€™s not just a good framework, itâ€™s incredibly well written, made up of many discrete parts that play well together.





---



*Whew! That feels like quite a lot to process. Perhaps weâ€™re at a good point to draw a line under this for now. Why not have a breather away from whatever screen youâ€™re looking at. Check on your dinner, play with the dog, or just go stare out the window and dream of Paris.*

In case you do come back, if youâ€™ve got any questions, comments, criticisms, or insights, Iâ€™d love to hear them. And if youâ€™d like to read more about how weâ€™re working with Laravel and Lumen at Elvie, Iâ€™ve got loads more to share, so please give this article a clap so I know youâ€™re interested in reading more about this.

